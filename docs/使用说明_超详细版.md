# AE-CS模型使用说明（超详细版）

> 📌 **基于专利算法的工业时序数据补全系统 - 完整使用指南**
> 
> 最后更新：2026-02-05 (v4.0 "Deep Therapy" Update)

---

## 📁 第一部分：项目文件结构与重要代码文件

### 1.1 核心代码文件（⭐ 必读）

```
D:\数据补全\
├── 【训练与评估】
│   ├── train.py                      # ⭐ 主训练脚本 (CPU强制模式，防OOM)
│   ├── evaluate.py                   # ⭐ 模型评估脚本 (生产级)
│   ├── test_iterative_imputation.py  # ⭐ 循环插补测试脚本 (New!)
│
├── 【数据文件】
│   └── hangmei_90_拼接好的.csv       # ⭐ 原始工业数据（2793行×44特征）
│
├── 【模型定义】 (models/)
│   ├── __init__.py
│   ├── ae_cs.py                      # ⭐⭐⭐ 核心：AE-CS v4 架构
│   │                                 #   - 3-Stream Encoder (Refined!)
│   │                                 #     1. Encoder_Orig (Zero-filled)
│   │                                 #     2. Encoder_Space (Spatial KNN Init)
│   │                                 #     3. Encoder_Time (Temporal KNN Init)
│   │                                 #   - GatingNetwork (with GAP & missing_rate)
│   ├── iterative_imputation.py       # ⭐⭐⭐ 循环插补模块 (New!)
│   │                                 #   - IterativeImputer: 解决均值回归的核心武器
│   │                                 #   - 动态更新邻域关系
│   ├── losses.py                     # ⭐ 损失函数定义
│   │                                 #   - missing_position_loss (伪标签抗均值回归)
│   │                                 #   - Consistency, Reconstruction, Manifold Losses
│   └── neighborhood.py               # ⭐ 时空邻域搜索模块
│                                     #   - Partial Distance (部分距离策略)
│                                     #   - Variable-level Mapping (变量级映射)
│
├── 【数据处理】 (data/)
│   ├── preprocessor.py               # ⭐ 数据预处理
│   ├── dataset.py                    # ⭐ 数据加载器
...
```

### 1.2 核心架构升级说明 (v4.0 "Three Lesions" Therapy)

本次更新针对模型的三大病灶（均值回归、幻觉、平坦恐惧）进行了底层重构：

#### 1. 三路编码器架构 (The Trinity Architecture)
即使在 `models/ae_cs.py` 中，模型现在显式包含三个独立的编码器实例，分别处理三种不同的输入视图：
*   **Encoder Orig**: 输入仅经过零填充。负责提取基础特征。
*   **Encoder Space**: 输入使用 **Spatial KNN**（空间近邻）的加权均值进行初始化。这强迫模型关注空间相关性，解决"幻觉"问题。
*   **Encoder Time**: 输入使用 **Temporal KNN**（时间近邻）的加权均值进行初始化。这强迫模型关注时间趋势。

#### 2. 自适应门控网络 (Enhanced Gating)
`components.GatingNetwork` 引入了 **全局平均池化 (GAP)** 和偏置项，并显式输入 **缺失率 (missing_rate)**。这使得模型能根据当前的稀疏程度，智能决定是相信原始数据，还是相信邻域推断。

#### 3. 循环插补 (Iterative Imputation) - `models/iterative_imputation.py`
这是本次更新的杀手锏。为了彻底根治"均值回归"，我们引入了动态循环机制：
*   **Round 1**: 模型基于部分观测数据给出一个初步预测。
*   **Round 2+**: 使用上一轮的填充结果，**重新计算** KNN 邻居和距离。
    *   *逻辑*: 随着数据的填充，原本因为缺失而找不到的"真邻居"现在浮出水面。
    *   *效果*: 信息从观测区域逐步向深层缺失区域传播，细节越来越清晰，不再是一条直线。

#### 4. 损失函数革新 - `models/losses.py`
*   **Missing Position Loss**: 引入了针对缺失位置的伪标签损失。我们不再让缺失位置"自生自灭"，而是用 KNN 的初始化值作为软目标（Soft Target）进行监督，防止预测值坍缩为全局均值。

---

## 🚀 第二部分：快速开始

### 2.1 训练新模型 (Training)

由于代码架构升级，训练脚本 `train.py` 已经适配了新的 `AECS` 类。默认配置已调整为"治疗模式"参数。

```bash
# 推荐训练命令 (CPU模式，稳定第一)
python train.py --batch_size 4 --k_spatial 10 --lambda4 0.1
```

*   `--k_spatial 10`: 增加邻居数量，利用更多上下文。
*   `--lambda4 0.1`: 启用邻域强约束 (注意: 根据losses.py的代码确认具体参数名，通常通过config传递)。

### 2.2 模型评估与循环插补 (Evaluation)

要体验"循环插补"带来的性能提升，请使用评估脚本并开启迭代模式。

```python
# 伪代码示例 (在 evaluate.py 或 notebook 中)
from models.ae_cs import AECS
from models.iterative_imputation import IterativeImputer

# 1. 加载模型
model = AECS(...)
model.load_weights(...)

# 2. 初始化循环插补器 (核心步骤!)
imputer = IterativeImputer(
    model, 
    max_iters=5,          # 迭代5次
    recompute_knn=True,   # 每次都重新找邻居
    verbose=True
)

# 3. 执行插补
X_filled, history = imputer.impute(X_input, mask)
```

---

## 🔧 第三部分：常见问题 (Q&A)

**Q: 为什么我的预测还是一条直线？**
A: 请检查是否启用了 `IterativeImputer`。单次推理在极高缺失率下仍可能趋向均值，循环插补通过多轮细化能从噪音中提取出波动趋势。

**Q: 训练速度变慢了？**
A: 是的。现在的 `AECS` 内部运行了三个编码器（参数量增加），且邻域搜索（KNN）计算量较大。这是为了精度和鲁棒性所做的必要权衡。建议使用较小的 Batch Size (如 4 或 8)。

**Q: `loss_missing` 是什么？**
A: 这是为了防止模型偷懒（全部预测为0或均值）而加入的约束项。它强迫模型对于缺失部分的预测，至少不能偏离 KNN 的统计推断太远。
